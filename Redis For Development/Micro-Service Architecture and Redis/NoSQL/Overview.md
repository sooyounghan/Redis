-----
### NoSQL의 등장 배경
-----
1. 소프트웨어의 핵심은 데이터이므로, 올바른 데이터 저장소를 선택하고 운영하는 문제는 중요하며, 이는 곧 애플리케이션의 성능과 확장성, 가용성과 신뢰성 등 여러 문제와 직접적 연관을 가짐
2. 모놀리틱 아키텍쳐
   - 전통적인 소프트웨어 개발모델
   - 전체 애플리케이션을 하나의 통합된 패키지로 개발, 배포하는 방식
   - 모든 시스템은 하나로 연결되어 관리
<div align="center">
<img src="https://github.com/user-attachments/assets/dd84368b-86ef-43c2-ae11-e8b14fa52e19">
</div>

   - 작은 규모의 프로젝트나 애플리케이션에서는 모놀리틱 구조가 운영하기 쉬울 수 있음
   - 하지만, 서비스 규모가 확장되면 유지보수의 복잡도도 증가할 수 밖에 없음 (한 개의 시스템에 문제가 생기면, 곧 전체 시스템 장애로 이어짐)
   - 또한, 하나의 모듈을 수정하면 전체 애플리케이션을 다시 배포해야 하며, 서버의 기동과 빌드, 배포에 드는 시간이 길어짐
     대량 트래픽, 복잡한 트랜잭션 등 요구 사항에도 유연하게 대처하기 힘들어짐
     프레임워크나 언어의 변경이 전체 애플리케이션에 영향을 끼치므로 작은 기능을 변경하는 것에도 어려움이 커져 민첩하게 대처하기 어려워짐
     즉, 서비스 중 하나의 파트에서 리소스가 모자라 확장을 하고 싶어도 서비스 전체 확장을 할 수 밖에 없고, 이는 리소스 낭비로 이어짐

3. 마이크로서비스 아키텍쳐
   - 독립된 각각의 모듈을 조립해 하나의 서비스를 만드는 아키텍쳐
   - 기능별로 작게 나뉘어진 서비스가 독립적으로 동작하는 서비스를 의미
   - 업데이트, 테스트, 배포, 확장은 각 서비스별로 독립적으로 수행될 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/8217bac9-382e-480e-bcab-4574010bfcfa">
</div>

   - 빠르게 성장하는 프로젝트라면, 마이크로서비스 아키텍쳐 구조를 채택하는 것이 좋음
   - 새로운 기능을 추가해 배포하는 것이 비교적 편맇기 때문에 요구 사항에 민첩하게 대처할 수 있고, 하나의 애플리케이션 내 특정 서비스 규모가 커져 해당 서비스 확장이 필요할 때 원하는 서비스와 서버만 쉽게 업그레이드 할 수 있어 서비스를 유연하게 관리 가능
   - 또한, 각 서비스에 맞게 다양한 개발 도구를 자유롭게 선택할 수 있어 기술 발전이 활성화되고, 서비스 간 독립성으로 인해 한 서비스에서의 문제가 다른 서비스에 큰 영향을 주지 않아 운영의 안정성 향상
   - 다만, 모든 서비스가 마이크로서비스 아키텍쳐를 적용하기에 적합한 것은 아님
     + 개발 및 운영을 위해 대규모 인원이 투입될 수 있는 서비스에서는 장점을 누릴 수 있음
     + 하지만, 소규모 팀에서의 서비스 분리로 인해 관리와 복잡도와 운영 부담이 증가할 수 있음

-----
### 데이터 저장소 요구 사항의 변화
-----
1. 모놀리틱 서비스에서 애플리케이션 개발을 위해 가장 많이 사용된 서비스 : Oracle Server, MySQL 등 관계형 데이터베이스
   - 관계형 데이터베이스는 고정된 스키마를 갖고 있으며, 모든 데이터를 행과 열로 구성된 테이블에 저장하며, 각 테이블 간 관계를 정확하게 규정
   - 이러한 관계는 특히 애플리케이션이 커질수록 매우 복잡해지며 데이터를 추출하기 위한 쿼리 또한 복잡해짐
   - 관계 간의 복잡성으로 인해 쿼리 성능 문제가 발생하며, 성능을 향상시키기 위해 쿼리, 인덱스, 테이블 구조를 자주 최적화 해줘야 함

2. 애플리케이션에서 사용하는 모든 데이터를 하나의 데이터베이스에서 관리하고자 했기 때문에 모놀리틱 아키텍쳐에서는 중앙 집약적 관계형 데이터베이스를 표준으로 삼아왔으며, 그로인해 관계형 데이터베이스는 데이터베이스의 표준이 될 수 있었음
   - 복잡한 조직 전체에서 데이터를 관리하기 위해서 관계형 모델이 답이 될 수 있었으며, 이로 인해 데이터베이스 간의 관계를 잘 정리하는 것이 서비스 성능에 큰 영향을 미치기도 했음
   - 관계형 데이터베이스의 특성 : ACID
     + 원자성 (Atomicity) : 트랜잭션이 완벽하게 실행되거나 아예 실행되지 않음을 보장
     + 일관성 (Consistency) : 트랜잭션은 실행 전후로도 제약 조건을 만족시킴을 보장
     + 독립성 (Isolation) : 트랜잭션 실행 시 다른 트랜잭션 개입이 없음을 보장
     + 지속성 (Durability) : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 보장

3. 하지만 최근 서비스에서는 정해진 형태가 없고, 크기와 구조를 예측할 수 없는 비정형 데이터가 증가하고 있음
   - 이러한 비정형 데이터는 다차원적이거나 깊은 계층 구조를 가질 수 있어 관계형 데이터베이스의 정형화된 테이블에서는 관리하기 어려움
   - 예를 들어, 그래프화된 데이터를 관계형 데이터베이스에서 저장하려면 이를 변환하기 위해 다시 계산해야 하는 문제 발생
     + 실시간 로그 데이터와 같은 시계열 데이터는 실시간으로 데이터를 저장해야 하는 서비스이며, 이를 관계형 데이터베이스에 저장할 때는 쓰기 성능 이슈가 발생할 수 있음
     + JSON 데이터를 관계형 데이터베이스에 저장하는 것 또한 쉽지 않음 (다양한 필드를 가지고 있으므로, 관계형 데이터베이스에 저장하기 위해서는 먼저 해당 필드들을 분석하고 그에 알맞은 컬럼을 정의해야 함)
   - 또한, 관계형 데이터베이스를 사용하는 일부 기업에서는 테이블 구조 변경을 위해 데이터 아키텍쳐의 승인을 거치고 DBA가 작업을 진행하는 데이터 관리 체계로 인해 개발 속도가 저하될 수 있음
   - 반면, NoSQL을 사용할 경우 바로 데이터 구조를 바꿀 수 있어 빠른 개발이 가능하다는 장점 존재

4. 즉, 비즈니스 특성과 데이터 형태를 고려하지 않고 관계형 데이터베이스만을 고집하는 것은 비효율적 데이터 모델을 갖는 시스템이 될 수 있음
5. 마이크로서비스 아키텍쳐에서 가장 중요한 것은 각 서비스가 독립적으로 동작할 수 있도록 하나의 서비스가 다른 서비스들과 밀접하게 연관되지 않아야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/d7d2bd37-eb30-4495-95e0-5201bc8f43eb">
</div>

   - 즉, 마이크로서비스 아키텍쳐의 각 서비스는 스스로 상태를 유지해야 하며, 이를 위해 독립된 데이터 저장소가 필요
   - 각 서비스는 각각 하나의 역할을 수행하기 위해 설계된 독립적 파트이므로, 서비스별 비즈니스 특성과 데이터 형태를 고려해 관계형 데이터베이스 또는 NoSQL 데이터베이스를 선택해 사용할 수 있음
