-----
### 마이크로서비스 아키텍쳐와 레디스
-----
1. 레디스는 마이크로서비스 아키텍쳐에서 데이터 저장소 그 이상으로 활용될 수 있는 데이터베이스
2. 데이터 저장소로서의 레디스
   - 레디스는 마이크로서비스 아키텍쳐에서 각 서비스별 개별 저장소로 사용하기에 알맞음
   - 설치가 간편하고, 최소한의 리소스로 막대한 처리량을 낼 수 있으며, 다양한 자료 구조를 제공하면서도 사용이 간단하므로 마이크로서비스 요구 사항에 맞는 데이터를 저장하기에도 편함
   - 또한, 고가용성을 위해 로드 밸런서나 프록시 등 추가적 서비스를 설치할 필요가 없어 하나의 저장소로 역할을 수행하기에 충분
   - 메모리에 있는 데이터가 영구 저장되지 않으므로, 데이터 저장소로 사용하기 위해 레디스 도입 시 데이터 영속성을 고민할 수 있으나, 레디스의 데이터는 AOF(Append Only File)와 RDB(Redis Database) 형식으로 디스크에 주기적 저장 가능
   - 레디스는 장애가 발생해 데이터가 유실되더라도 백업 파일을 이용하면 다시 복구 가능

3. 메세지 브로커로서의 레디스
   - 마이크로서비스 아키텍쳐에서 각 서비스는 완전히 분리되어있는 구조로 동작하므로, 서로 다른 서비스 간에 지속적 통신이 필요
   - 메세징 큐 혹은 스트림(Stream)과 같은 메세지 브로커를 이용해 서비스들 간 비동기적으로 데이터를 전달할 수 있는 통신 채널을 구현하는 것이 좋음
   - 레디스는 NoSQL 데이터 저장소로 알려져있으므로, 단순한 데이터를 저장할 수 있는 저장소로만 생각할 수 있지만, 서비스 간 메세지를 전달할 때 매우 유용하게 사용 가능
   - 레디스의 pub/sub 기능은 가장 간단한 메세징 기능으로, 굉장히 빠르게 동작하고 간단하게 사용 가능
      + 하나의 채널에 데이터를 던지면 이 채널을 듣고 있는 모든 소비자는 데이터를 빠르게 가져갈 수 있음
      + pub/sub에서 모든 데이터는 전달된 뒤 삭제되는 일회성으로, 모든 메세징 상황에서 적합하지 않지만 Fire-and-Forget 패턴이 필요한 간단한 알림(Notification) 서비스에 유용하게 사용 가능
    
   - 레디스의 list 자료 구조는 메세징 큐로 사용하기 알맞음
     + list에는 데이터를 빠르게 push/pop 할 수 있으며, 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 list에 새로운 데이터가 들어오면 읽을 수 있는 블로킹 기능을 사용할 수 있음
    
   - 레디스의 stream 자료 구조를 이용하면, 레디스를 완벽한 스트림 플랫폼으로 사용할 수 있음
     + stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조
     + 데이터는 계속해서 추가되는 방식으로 저장(Append-Only)
     + 카프카처럼 저장되는 데이터를 읽을 수 있는 소비자와 소비자 그룹이 존재해 데이터 분산 처리도 가능하며, 저장된 데이터를 시간대별로 검색하는 것도 가능
