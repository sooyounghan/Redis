-----
### 레디스(Redis)
-----
1. Remote Dictionary Server의 약자로, 고성능 키-값 유형의 인메모리(In-Memory) NoSQL 데이터베이스
2. 오픈 소스 기반 데이터 저장소
3. 2017 ~ 2021년까지 5년 연속으로 스택 오버플로우에서 개발자들에게 사랑받는 데이터베이스로 선정
4. 레디스의 특징
   - 실시간 응답 (빠른 성능)
     + 인메모리 데이터베이스(In-Memory Database)와 온디스크 데이터베이스(Disk-based Database)의 특징
<div align="center">
<img src="https://github.com/user-attachments/assets/9e31a3ef-8664-4b00-a59f-94e4f1dcb1c1">
</div>

   - 대부분의 데이터베이스는 온디스크 형태로, 온디스크 형태의 데이터베이스에서 데이터는 영구적으로 디스크에 저장
     + 자주 사용되는 데이터는 캐싱되어 메모리에 올라와 있는 경우도 존재하지만, 그렇지 않은 데이터를 찾고자 할 때는 직접 디스크에 가서 데이터를 검색하는 과정을 거쳐야 함
     + 이 때, 디스크에 저장된 데이터는 바로 찾을 수 없으며, 디스크의 데이터를 페이지 단위로 메모리에 올린 뒤, 데이터를 찾고, 없는 경우, 다시 다른 페이지를 디스크에서 가져와 메모리에 올린 뒤 찾는 과정 반복
     + HDD와 SSD와 같은 디스크에 접근하는 속도는 RAM과 같은 메모리에 접근하는 속도보다 현저히 느리므로, 디스크에 접근하는 빈도가 증가할수록 시스템 성능은 저하

   - 인 메모리 형태의 데이터베이스에서는 모든 데이터가 컴퓨터의 메모리에서 관리 : 디스크에 접근하는 과정이 필요없으므로 데이터 처리 성능이 굉장히 빠르다는 장점 존재
<div align="center">
<img src="https://github.com/user-attachments/assets/ad618e24-ec85-4216-af43-5d0893a76975">
</div>

   - 단순성
<div align="center">
<img src="https://github.com/user-attachments/assets/5e4ba98e-199d-40f1-a633-3d3e27ed4643">
</div>

   - 레디스는 키-값 형태로 데이터를 관리할 수 있는 데이터 저장소
   - 키에 매핑되는 값에는 문자열(String)뿐만 아니라 해시(Hash), 셋(Set) 등 더욱 복잡하고 다양한 데이터 구조를 저장할 수 있도록 지원 : 프로그래밍의 기본 자료 구조와 밀접한 관련이 있어 추가적 데이터 가공 없이 애플리케이션에서 쉽게 사용 가능
   - 임피던스 불일치(Impedence Mismatches) : 기존 관계형 데이터베이스의 테이블과 프로그래밍 언어 간 데이터 구조, 기능의 차이로 발생하는 충돌을 의미
     + 레디스는 내장된 다양한 자료 구조를 통해 임피던스 불일치를 해소하고 개발을 편리하게 할 수 있도록 지원
     + 또한, 레디스 개발자는 100개가 넘는 오픈 소스 클라이언트를 사용할 수 있으며, 개발자에게는 다수의 언어 지원
<div align="center">
<img src="https://github.com/user-attachments/assets/35114419-db72-40f5-a9f8-526f7f09f3c2">
</div>

   - 💡 레디스는 싱글 스레드로 동작 : 메인 스레드 1개와 별도의 스레드 3개, 총 4개의 스레드로 동작
     + 하지만, 클라이언트의 커맨드를 처리하는 부분은 이벤트 루프를 이용한 싱글 스레드로 동작
     + 최소 하나의 코어만 있어도 레디스를 사용할 수 있어 배포가 쉽고, CPU가 적은 서버에서도 좋은 성능을 낼 수 있음
     + 또한, 멀티스레드 애플리케이션에서 요구되는 동기화나 잠금 메커니즘 없이도 안정적이고 빠르게 사용자 요청 처리 가능
     + 그러나, 레디스가 싱글 스레드로 동작한다는 것은 한 사용자가 오래 걸리는 커맨드를 수행하면, 다른 사용자는 그 쿼리가 완료될 때까지 대기할 수 밖에 없다는 단점 존재 : 인적 장애 발생 가능성이 높음
     + 레디스는 메모리에서 동작하므로 대부분 커맨드는 빠른 응답 시간을 가지만, 반환이 느린 특정 커맨드도 존재하는데, 이런 커맨드만 주의해서 사용해도 장애 가능성을 줄일 수 있음

   - 고가용성
     + 레디스는 자체적으로 고가용성(HA, High Availability) 기능 제공
     + 복제를 통해 데이터를 여러 서버에 분산시킬 수 있으며, 센티널(Sentinel)은 장애 상황을 탐지해 자동으로 페일오버(Fail-Over)를 시켜줌
     + 애플리케이션이 센티널을 이용해 레디스에 연결하는 구조에서는 마스터에 장애가 발생하더라도 레디스로의 엔드포인트를 변경할 필요 없이 페일오버가 완료돼 정상화된 마스터 노드 사용 가능

   - 확장성
<div align="center">
<img src="https://github.com/user-attachments/assets/850bff7c-7513-41d9-9ec4-73a93dc3ee90">
</div>

   - 레디스에서 클러스터 모드를 사용한다면, 손쉬운 수평적 확장이 가능
   - 데이터는 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러 개 복제본이 생성될 수 있음
   - 이 데이터 분리는 데이터베이스 레이어에서 처리되며, 애플리케이션에서는 대상 데이터가 어떤 샤드에 있는지 신경 쓰지 않아도 되며, 레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있음
   - 클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 통해 서로 감시하고 있으며, 이를 이용해 클러스터의 마스터 노드에 문제가 발생하면 자동으로 페일오버를 시켜 고가용성 유지 가능

   - 클라우드 네이티브 : 멀티 클라우드
<div align="center">
<img src="https://github.com/user-attachments/assets/f911f590-b877-4ab0-9e86-43c66f789e7f">
</div>

   - 클라우드 네이티브는 클라우드 환경에 특화된 애플리케이션의 개발 및 운영 방식을 의미
     + 이 방식은 마이크로서비스, 컨테이너, 오케스트레이션 그리고 데브옵스와 같은 현대 개발 및 운영 패러다임을 포용하며, 빠른 배포와 확장성, 높은 복원력을 중심으로 한 애플리케이션 추구
     + 레디스는 이러한 클라우드 네이티브 환경에서 빠른 데이터 액세스 및 처리를 지원하는 구조로 인해, 마이크로서비스 아키텍쳐와의 연계에서 큰 장점을 지님

   - 멀티 클라우드는 여러 클라우드 제공업체 서비스를 동시에 혹은 혼합해 활용하는 전략을 의미
     + 단일 클라우드 환경의 장애나 제한된 자원에 대한 의존성을 줄이며, 각 클라우드 서비스 제공자의 강점을 활용할 수 있게 해줌
     + 또한, 데이터가 특정 지역이나 국가 내 물리적으로 위치하도록 조절할 수 있으며, 더 가까운 저장소에서 데이터를 처리하게 되므로 대기 시간을 줄이고 장애 상황에 더욱 강건하게 대응 가능
     + 멀티 클라우드 전략에서 레디스는 그 중요성을 발휘해, 여러 클라우드 환경에 걸쳐 일관된 성능과 기능을 제공함으로써 서비스 연속성과 데이터 일관성 보장

5. 국내 주요 클라우드 벤더들은 레디스를 상품화해 다양한 서비스 제공
   - AWS : Amazon ElasticCache for Redis
   - Google Cloud : Cloud Memory stor for Redis
   - Microsoft Azure : Azure Cache for Redis
   - 국내 클라우드로는 NHN Cloud가 EasyCache를, Naver Cloud가 Cloud DB for Redis 제공
   - 이를 활용해 대규모 서비스를 구축하면 높은 가용성, 확장성 그리고 강력한 성능을 달성할 수 있으며, 이를 통해 사용자에게 더욱 빠르고 안정적 서비스 제공 가능
