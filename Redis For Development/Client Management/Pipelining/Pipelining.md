-----
### 파이프라이닝
-----
1. 레디스 서버와 클라이언트는 네트워크로 연결되어 있으며, 요청과 응답 사이 왕복 시간(RTT, Round-Trip Time)은 성능에 큰 영향을 미침
   - 예를 들어, 왕복 시간이 250ms인 경우, 레디스 서버가 초당 10만 개 요청을 처리할 수 있더라도 네트워크 통신에 소요되는 시간 때문에 최대 4개의 요청만을 처리
   - 따라서, 네트워크 통신 소요 시간을 줄임으로써 레디스 성능을 크게 향상시킬 수 있음

2. 레디스에서 파이프라이닝은 클라이언트가 연속적으로 여러 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능
   - 일반적으로 클라이언트는 레디스 서버에 하나의 커맨드를 보내고, 서버에서 그 커맨드를 처리한 결과를 받은 후 다음 커맨드를 보내는 방식으로 동작
   - 파이프라이닝을 사용하면 한 번에 여러 개 커맨드를 일괄적으로 처리할 수 있는 방식으로 동작하므로, 응답 속도를 줄이고 처리량을 늘릴 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/09c6aa4b-daf4-43a8-9738-e749e2eea133">
</div>

3. 레디스에서 파이프라이닝을 사용하는 방법
   - 레디스 서버에 줄바꿈을 이용해 동시에 실행할 여러 개 커맨드를 한 번에 보내면 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/94fe5440-744f-4d47-b760-7fbdb89da174">
</div>

   - 위와 같이 커맨드를 보내면 한 번의 왕복 시간을 이용해 3개의 커맨드를 처리할 수 있으므로 수행 시간 절약
   - 레디스 클라이언트 라이브러리를 이용하면 더욱 직관적 방법으로 파이프라인 기능을 사용 가능
   - 예) 파이썬에서 redis-py 라이브러리를 사용해 파이프라인 기능 사용하는 코드
<div align="center">
<img src="https://github.com/user-attachments/assets/d85662a8-ce22-47c3-80fc-b6780af95014">
</div>

   - 파이프라이닝을 이용하면 왕복 시간을 줄일 수 있을 뿐만 아니라 레디스 서버의 처리량도 크게 향상 가능
   - 레디스 서버가 클라이언트에 응답하기 위해 소켓 I/O를 수행할 때 운영체제 커널 영역의 read(), write() 시스템 콜을 호출하는 과정에서 발생하는 레이턴시(Latency) 증가가 레디스 서버에서 데이터를 찾고 반환하는 과정보다 큼
     + 파이프라이닝을 사용하면 여러 명령이 read() 시스템 콜로 읽혀지고 여러 응답이 단일 write() 시스템 호출로 전달되므로 시스템 콜을 줄일 수 있어 처리량 줄일 수 있음
   - 따라서, 파이프라이닝에 속한 커맨드가 많아질수록 초당 수행되는 총 쿼리 수가 거의 선형적으로 증가

4. 파이프라이닝을 사용했을 때 성능 향상을 확인하기 위한 테스트
   - 레디스에 접속해 100만개 키를 가져온 뒤, 타입과 메모리 사용량을 파악하는 코드 (파이썬)
<div align="center">
<img src="https://github.com/user-attachments/assets/ba0825ac-1e07-4cf5-adac-9929bcc1e5f6">
</div>

   - 실행 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/069919b5-5cfa-409f-bcdc-ecef13d4c205">
</div>

   - SCAN 커맨드를 이용해 키를 가져온 뒤, 각 키의 타입과 메모리 사용율을 확인하는 방식으로 동작하는 코드
   - 1200만 개의 키가 있는 레디스를 수행했을 때 4시간 20분 소요

   - 파이프라인을 이용하는 방식으로 변경
<div align="center">
<img src="https://github.com/user-attachments/assets/3454998b-8fe1-442f-bd5f-eb5f1e868193">
</div>

   - 실행 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/e8a23a9f-aa9b-4a56-8eb2-50df1f9c4249">
</div>

   - 같은 장비에서 같은 레디스 인스턴스를 대상으로 한 작업으로, 데이터 수집 알고리즘만 파이프라인으로 변경했을 뿐인데, 작업 속도가 현저히 향상
   - 첫 번째 코드는 작업에 4시간 넘는 시간이 소요됐지만, 파이프라인을 도입한 두 번쨰 방법은 단 3분 33초만에 작업 완료 (약 142배의 성능 향상 의미)

5. 레디스에서 데이터를 가져오는 두 가지 방법의 성능 비교 그래프
<div align="center">
<img src="https://github.com/user-attachments/assets/9eb1f273-6541-4be1-984c-d3cb2850de53">
</div>

   - 첫 번째 방법 : 4시간 동안 평균 800개의 커맨드 처리
   - 두 번쨰 방법 : 4분도 되지 않는 시간에 평균 66000개의 커맨드 처리
   - 파이프라인을 효과적 활용함으로써 네트워크 I/O를 최소화하면, 확실하고 상당한 성능 향상을 이룰 수 있음

6. 파이프라이닝 사용 시 주의할 점
   - 한 번에 너무 많은 쿼리를 파이프라인을 이용해 레디스에 보내게 되면, 네트워크 대역폭 한계로 인해 속도 저하가 될 수 있음
   - 레디스 클라이언트 쿼리 버퍼 제한에 걸려 오류가 발생할 수 있음
   - 그러므로 여러 개의 명령을 파이프라이닝으로 처리하고자 할떄, 명령을 일정한 개수로 나누어 배치(Batch) 형태로 서버에 보내는 것이 좋음
     + 예를 들어, 10만 개의 커맨드를 한 번에 보내고, 응답을 받은 다음 그 다음 10만 개의 커맨드를 다시 보내는 식으로 처리하는 것이 좋음
   - 이렇게 하면 처리 속도는 거의 동일하지만, 레디스 서버 측 메모리를 효율적 활용 가능

7. 배치 사이즈
   - 충분한 테스트를 통해 결정하는 것이 좋음
   - 한 번에 너무 많은 커맨드를 처리하면, 네트워크 대역폭을 너무 많이 차지하거나, 레디스의 CPU 부하나 클라이언트 버퍼로 인해 메모리 증가가 발생해 성능 문제가 오히려 발생할 수 있음
   - 파이프라이닝하려는 레디스 데이터의 종류와 크기에 맞게 적절한 테스트를 한 이후, 배치 사이즈를 조절해보며 결정하는 것이 좋음

8. 레디스가 파이프라인으로 들어온 명령을 처리할 때, 하나의 파이프라인에 속하더라도 원자성을 보장하지 않음
   - 파이프라인은 여러 개의 커맨드를 동시에 보낼 수 있는 방법을 제공하며, 파이프라이닝을 통해 커맨드를 실행할 때 다른 클라이언트의 접근을 차단하지 않고, 파이프라인 내부의 각 커맨드만이 원자적 수행
   - 클라이언트 1과 클라이언트 2가 파이프라이닝을 이용해 레디스 서버에 접근하는 시점을 나타낸 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/59a1cf5e-4f0f-4f24-b913-498edfc4a311">
</div>

   - 클라이언트 1이 먼저 서버에 접근해 커맨드를 실행하고 있다하더라도, 클라이언트 2의 신규 연결을 차단하지 않음
   - 각각의 명령은 다른 연결 사이에서 교차로 수행될 수 잇음
   - 파이프라이닝을 이용한 연결은 원자적이지 않으며, 트랜잭션 개념이 아니므로, 파이프라인 내 속한 여러 커맨드 중 일부에 오류가 발생하더라도, 전체적 커맨드가 롤백되지 않음
   - 대신, 오류를 발생시키 커맨드만 수행되지 않고, 그 외 커맨드는 정상적으로 수행
