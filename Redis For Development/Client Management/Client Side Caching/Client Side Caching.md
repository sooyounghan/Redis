-----
### 클라이언트 사이드 캐싱
-----
1. 레디스 버전 6에서 클라이언트 사이드에서 캐싱을 할 수 있는 기능 추가
   - 데이터베이스 성능도 최적화했고, 레디스 같이 빠른 캐시를 사용하고 있음에도 만족할만한 성능이 나오지 않는다면, 클라이언트 사이드 캐시의 도입을 고려해볼 수 있음

2. 클라이언트와 레디스 서버 간 통신에서 가장 많은 시간을 차지하는 것은 네트워크 I/O, 즉 왕복 시간을, 이 시간을 줄이는 것이 애플리케이션 성능을 향상시키는 가장 큰 방법일 수 있음
   - 왕복 시간을 줄일 수 있는 방법 중 하나는 쿼리가 드렁올 때마다, 레디스 서버에 데이터를 요청하는 대신, 클라이언트 측에서 데이터를 로컬에 캐싱하고, 필요할 때 해당 데이터를 반환하는 것
   - 이를 클라이언트 사이드 캐싱이라 하며, 다음과 같이 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/3d249821-168f-484e-9c46-2d14640568e6">
</div>

   - 일반적으로 데이터를 질의할 때, 애플리케이션 서버는 레디스에 데이터를 요청한 뒤, 결과를 가져옴
   - 하지만 클라이언트 사이드 캐싱을 이용하면, 애플리케이션은 자주 사용되는 쿼리 응답을 애플리케이션 메모리에 직접 저장해, 나중에 저장소에 다시 쿼리하지 않고도 응답을 재사용할 수 있도록 함
   - 로컬 캐싱을 이용하면 네트워크를 이용하지 않고, 데이터를 반환하므로 응답 시간을 크게 단축 가능
   - 또한, 레디스에 접근하지 않고도 데이터를 반환하므로 레디스 서버의 부하를 줄일 수 있음

3. 데이터셋의 아이템이 자주 변경되지 않는 상황에서는 클라이언트 사이드 캐싱을 사용하는 것이 합리적일 수 있음
   - 예를 들어, SNS에 한 번 업로드한 사용자 게시물은 잘 변하지 않으며, 수정도 드물게 발생
   - 보통 SNS에서는 일부 사용자들이 굉장히 많은 팔로워를 가지고 있는 구조이므로 이런 패턴의 애플리케이션에서는 캐싱을 사용하는 것이 상당히 유용할 수 있음

4. 하지만 대부분 캐싱 패턴이 가지는 문제와 동일하게, 데이터의 정합성, 즉 업데이트된 데이터를 처리하는 방법을 고려해야 함
   - 레디스의 클라이언트 사이드 캐싱에서는 이를 처리하는 방법을 트래킹이라 부름
   - 트래킹을 할 수 있는 두 가지 방법
<div align="center">
<img src="https://github.com/user-attachments/assets/5afc25c8-ec6b-4c7a-adc8-304846f74af1">
</div>

   - 기본 모드 : 레디스 서버가 클라이언트가 액세스한 키를 기억해서, 동일한 키가 수정될 때 무효 메세지를 전송
     + 레디스의 서버에서 이를 기억해야 하므로 메모리 비용이 들지만 정확하게 클라이언트가 갖고 있는 키에 대해서만 무효한 메세지를 보낼 수 있다는 장점 존재
   - 브로드캐스팅 모드 : 레디스 서버가 모든 키에 대한 액세스를 기억하려고 시도하지 않으며, 특정 프리픽스에 대해 접근한 클라이언트만 기억하므로 기본 모드보다 레디스 서버에서 사용하는 메모리가 적다는 장점 존재
     + 대신 클라이언트는 특정 프리픽스를 가진 키를 기억해야 하며, 자신이 소유하지 않은 키라 하더라도 해당 프리픽스와 일치하는 키가 변경될 때마다 변경 메세지를 수신하는 단점 존재
     + 이로 인해 레디스 서버는 CPU 자원 소비할 수 있음

5. 클라이언트 측 캐싱을 사용할 때에는 서비스 특성에 맞는 캐싱 모드를 신중하게 선택하는 것이 중요하며, 자주 요청되지만 드물게 변경되는 키를 효과적으로 갱신하는 것이 좋음
