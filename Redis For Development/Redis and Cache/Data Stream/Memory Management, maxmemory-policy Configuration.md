-----
### 메모리 관리와 maxmemory-policy 설정
-----
1. 레디스에서 키에 만료 시간을 설정해 데이터가 자동으로 삭제되도록 함으로써 데이터 수명을 관리할 수 있음
2. 하지만 레디스의 메모리는 제한적이므로 모든 키에 만료 시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득 차는 상황이 발생할 수 있음
3. 메모리의 용량을 초과하는 양의 데이터가 저장되면 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정
4. 레디스에서는 데이터의 최대 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 바식을 결정하는 maxmemory-policy 설정값을 사용해 메모리 관리
5. Noeviction
   - 기본값으로, 이 값은 레디스에 데이터가 가득차더라도 임의의 데이터를 삭제하지 않고, 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정값
   - 하지만 캐시에 데이터를 저장하지 못해 에러가 발생할 경우, 로직에 따라 장애 상황으로 이어질 수 있으며, 이런 상황에서는 관리자가 레디스의 데이터를 직접 지워야하므로 레디스를 캐시로 사용할 때 권장하지 않는 설정값
   - 데이터의 관리를 캐시에게 맡기지 않고, 애플리케이션 측에서 관리하겠다는 것을 의미
   - 데이터가 가득차더라도 캐시 내부적 판단으로 데이터를 삭제하는 것이 애매하다고 판단될 때 이 옵션을 사용
  
6. LRU eviction
   - LRU(Least-Recently Used) eviction은 레디스에 데이터가 가득 차 있을 때, 가장 최근에 사용되지 않는 데이터부터 삭제하는 정책
   - 최근에 액세스되지 않은 데이터는 나중에도 액세스될 가능성이 낮을 것이라는 가정을 전제하고 있음
   - 캐시는 나중에 사용될 가능성이 있는 데이터를 유지하는 것을 목표로 하므로, 효율적인 메모리 관리 방법
   - 레디스는 URL 알고리즘을 이용한 두 가지 설정 값을 가지고 있음
     + volatile-lru : 만료 시간이 설정되어있는 키에 한해서 LRU 방식으로 키를 삭제
       * 즉, 이미 만료 시간이 설정되어있는 키는 언젠가 삭제될 키라는 것을 의미하므로, 이런 키 중 가장 오래 사용되지 않은 키를 삭제
       * 만약, 레디스를 사용할 때, 임의적인 방식으로 삭제되면 안 되는 값에 대해서는 만료 시간을 지정하지 않는다면 volatile-lru 방식을 사용하는 것이 적합할 수 있음
       * 하지만, 이 또한 장애 상황 유발 가능 : 만약 레디스 내부 저장된 키에 모두 만료 시간이 지정되어있지 않다면, noeviction 상황과 동일해짐 (삭제할 수 있는 키가 하나도 없으므로 레디스에 더 이상 데이터를 저장할 수 없어 에러 반환)

     + allkeys-LRU : 레디스 공식 문서에는 레디스를 캐시로 사용할 경우, 잘 모를 경우 이 방식을 권장
       + 이 방식은 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제하므로 적어도 메모리가 꽉 찼을 때 장애가 발생할 상황은 방지 가능

7. LFU eviction
   - 레디스에 데이터가 가득찼을 때 가장 자주 사용되지 않은 데이터부터 삭제하는 정책
   - 자주 사용되지 않는 데이터는 나중에도 액세스 될 가능성이 낮을 것이라는 가정을 전제로 함
   - LFU와 LRU는 유사하지만, 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 점에서 특정 케이스에서 LRU보다 더 효율적일 수 있음
     + 키가 오랫동안 사용되지 않았더라도 과거에 자주 액세스했던 키라면 나중에 자주 사용될 수 있다는 가정하에 우선순위가 높아짐

   - 두 가지 설정값
     + volatile-lfu : 만료 시간이 설정되어 있는 키에 한해 LFU 방식으로 키를 삭제
       * 특정 상황에서 장애를 유발할 가능성이 존재

     + allkeys-lfu : 모든 키에 대해 LFU 알고리즘을 이용해 데이터 삭제

8. 참고 : 레디스에서 키를 삭제하기 위해 LRU와 LFU 알고리즘은 모두 근사 알고리즘으로 구현
   - 이는 메모리가 가득 찬 상황에서 가장 오래 사용되지 않거나 자주 사용되지 않은 키를 정확하게 찾아내는 것이 불필요하게 CPU 및 메모리 리소스를 소비할 수 있기 때문임
   - 일반적으로, noeviction 옵션을 사용하지 않는 한, 지정된 데이터는 특정 상황에서 삭제될 수 있다는 가정하에 알고리즘이 동작
   - 따라서, 정확한 키를 계산하는 것보다 특정 키를 근사치로 찾아내 효율적으로 데이터를 삭제하는 방법임

9. RANDOM eviction
    - 레디스에 저장된 키 중 하나를 임의로 골라내 삭제
    - 앞서 소개한 알고리즘을 사용하지 않으므로 삭제될 키 값을 계산하지 않아도 되는 점에서 레디스 부하를 줄일 수 있음
    - 하지만, 랜덤으로 데이터를 삭제하므로 나중에 사용될 수 있는 데이터를 삭제할 가능성이 높아지며, 이럴 경우, 데이터 저장소에서 다시 데이터를 갖고와서 캐시에 넣어주는 작업이 오히려 불필요하게 유발할 수 있음
    - 또한, 레디스는 근사 알고리즘을 사용하므로, LFU, RLU 데이터를 찾는 데 큰 리소스를 사용하지 않으므로, 따라서 굳이 레디스의 부하를 줄이기 위한 이유로 random eviction을 사용하는 것을 권장하지 않음
    - 두 가지 설정값
      + volatile-random : 만료 시간이 설정되어 있는 키에 한해 랜덤하게 키 삭제
      + allkeys-random : 모든 키에 대해 랜덤으로 키를 삭제

10. Volatile-TTL
     - 만료 시간이 가장 작은 키를 삭제
     - 즉, 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션
     - 이 알고리즘 또한, LRU / LFU 한 키를 골라는 알고리즘과 마찬가지로 근사 알고리즘을 이용
     - 따라서, 저장된 모든 키를 스캔하면서 만료 시간을 비교하지 않아도 되므로, 꽤 간단하게 키를 찾아낼 수 있음
