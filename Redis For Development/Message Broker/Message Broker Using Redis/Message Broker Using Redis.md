-----
### 레디스를 메세지 브로커로 사용하기
-----
1. 레디스에서 제공하는 pub/sub를 사용하면 빠르고 간단한 방식으로 메세지를 전달할 수 있는 메세지 브로커 구현 가능
   - 발행자가 특정한 채널에 데이터를 전송하면, 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비할 수 있음
   - 레디스의 pub/sub에서 모든 데이터는 한 번 채널 전체에 전파된 뒤, 삭제되는 일회성의 특징을 가지며, 메세지가 잘 전달됐는지 등 정보는 보장하지 않음

2. 따라서, 완벽하게 메세지가 전달되어야 하는 상황에서는 적합하지 않을 수 있지만 fire-and-forget 패턴이 필요한 간단한 알림(Notification) 서비스에서는 유용하게 사용 가능
   - Fire-and-Forget 패턴 : 비동기 프로그래밍에서 사용되는 디자인 패턴
     + 어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고, 바로 다음 코드를 실행하는 것
     + 이 패턴은 주로 성능 향상이나 비동기 작업을 수행할 때 사용되며, 작업의 완료나 결과에 대한 처리가 필요하지 않을 때 유용하게 사용
     + 예를 들어, 로깅 / 이벤트 발행 / 통계 데이터 숮비과 같이 작업의 성공 또는 실패에 대한 관심이 없는 경우 활용 가능
     + 이 패턴을 사용할 때는 결과 확인이나 오류 처리를 고려하지 않고, 작업을 진행하므로, 신뢰성이 필요한 경우 사용하지 않아야 함

3. 레디스의 list 자료 구조는 메세징 큐로 사용하기 알맞음
   - list의 데이터는 푸시와 팝이 가능하며, 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 list에  새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용할 수 있음

4. 레디스의 stream을 사용하면 완벽한 스트림 플랫폼으로 사용할 수 있음
   - 레디스 stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조로, 데이터는 계속해서 추가되는 방식으로 저장(Append-Only)
   - 소비자와 소비자 그룹이라는 개념을 이용하면, 카프카에서와 비슷하게 데이터의 분산 처리를 구현할 수 있음
   - stream에 저장되는 메세지를 실시간으로 리스닝하며 소비할 수 있으며, 저장되어 잇는 데이터를 시간대별로 검색하는 것도 가능
   
