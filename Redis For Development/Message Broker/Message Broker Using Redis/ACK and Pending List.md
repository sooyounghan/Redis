-----
### ACK와 보류 리스트
-----
1. 여러 서비스가 메세지 브로커를 이용해 데이터를 처리할 때, 예상치 못한 장애로 인해 시스템이 종료될 경우 이를 인지하고 재처리할 기능이 필요
2. 메세지 브로커는 각 소비자에게 어떤 메세지까지 전달했고, 전달된 메세지의 처리 유무를 인지하고 있어야 함
3. 레디스 stream에서는 소비자 그룹에 속한 소비자가 메세지를 읽어가면 각 소비자별 읽어간 메세지에 대해 리스트를 새로 생성하며, 마지막으로 읽어간 데이터의 ID로 last_delivered_id 값을 업데이트
   - last_delivered_id 값은 해당 소비자 그룹에 마지막으로 전달한 ID가 무엇인지 파악해, 동일한 메세지를 중복으로 전달하지 않기 위해 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/76f09b6d-b261-4504-8f54-34030fc01ec3">
</div>

   - 이메일 서버 1이라는 소비자가 2개의 메세지를 가져갔고, 서버 2가 1개의 메세지가 가져감
   - 레디스 stream은 소비자별로 보류 리스트(Pending List)를 만들고, 어떤 소비자가 어떤 데이터를 읽어갔는지 인지하고 있음

<div align="center">
<img src="https://github.com/user-attachments/assets/afd53aac-8de2-4132-9425-2bf622d72e43">
</div>

   - 만약 이메일 서비스 2가 stream에게 데이터가 처리됐다는 뜻의 ACK를 보내면, 레디스 stream은 이메일 서비스 2의 보류 리스트에서 ACK를 받은 메세지를 삭제

4. 즉, 보류 리스트를 이용해 소비자가 처리한 데이터를 파악할 수 있음
   - 예를 들어, 이메일 서비스에 문제가 발생해 서비스를 재부팅해야 하는 상황에서, stream의 보류 리스트에 데이터가 남아있는 경우 해당 데이터를 먼저 불러와 처리하는 작업을 선행적으로 수행한다면, 예상치 못한 서비스 중단 상황에서도 모든 메세지를 놓치지 않고 처리할 수 있게 됨
  
5. 만약, 이메일 서버 1에 장애가 발생해 해당 서버에 당분간 사용 할 수 없는 상태가 됐을 때, 1번 서버가 작업 중이던 메세지를 다른 서버에서 처리해야 할 수 있음
   - 이를 위해서 1번 서버의 보류 리스트에 남아 있는 메세지가 있는지 확인하는 과정을 거치면 됨
   - 따라서, XREADGROUP를 이용해 소비자 그룹 형태로 데이터를 읽었을 때, 데이터 처리가 완료된 후에 애플리케이셔에서 XACK를 주기적으로 전송하는 작업이 필요

6. 소비자 그룹에서 보류 중인 리스트가 있는지 확인
```redis
XPENDING <key> <groupname> [<start-id> <end-id> <count> [<consumer-name>]]
```
```redis
> XPENDING Email EmailServiceGroup
1) (integer) 9
2) "1659114481311-0"
3) "1659170736530-0"
4) 1) 1) "es1"
      2) "1"
   2) 1) "es2"
      2) "1"
   3) 1) "es3"
      2) "7"
```
   - 반환되는 첫 번째 값은 현재 소비자 그룹에서 ACK를 받지 못해 보류 중인 메세지 개수
   - 두 번째, 세 번째 값은 각각 보류 중인 메세지의 ID의 최솟값, 최댓값
   - 그 뒤로는 각 소비자별로 보류 중인 리스트가 몇 개 있는지 알려줌

7. XACK를 이용해 다음과 같이 데이터가 처리됐음을 알려줄 수 있음
```redis
> XACK Email EmailServiceGroup 1659114481311-0
(integer) 1
```
   - Email stream의 EmailServiceGroup 그룹에 속한 소비자가 1659114481311-0 ID를 가진 메세지를 처리했다는 의미를 가짐
     
```redis
> XPENDING Email EmailServiceGroup
1) (integer) 8
2) "1659114481311-0"
3) "1659170736530-0"
4) 1) 1) "es1"
      2) "1"
   3) 1) "es3"
      2) "7"
```

8. 카프카도 레디스 stream과 비슷하게 파티션별 오프셋을 관리
   - 카프카는 내부적으로 __consumer_offsets라는 토픽에 데이터를 기록
   - 소비자가 지정된 토픽의 특정 파티션의 메세지를 읽으면 소비자 그룹, 토픽, 파티션 내용이 통합되어 저장
   - 소비자 그룹은 __consmer_offsets 토픽에 기록된 정보를 이용해 내부 소비자가 어디까지 읽었는지 추적할 수 있음
   - 카프카에서 오프셋은 마지막으로 읽은 위치가 아니라 다음으로 읽어야 할 위치 기록
<div align="center">
<img src="https://github.com/user-attachments/assets/dc881329-4e1c-4236-8109-fc026befdcb4">
</div>
