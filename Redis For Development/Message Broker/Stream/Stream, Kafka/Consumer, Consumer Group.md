-----
### 소비자와 소비자 그룹
-----
1. 같은 데이터를 여러 소비자에게 전달하는 것 : 팬 아웃(Fan-Out)
   - 카프카에서는 같은 토픽을 여러 개의 소비자가 읽어가게 함으로써, 간단하게 팬아웃 할 수 있음
   - 카프카에서 Email이라는 토픽에 3개의 소비자가 연결된 그림
<div align="center">
<img src="https://github.com/user-attachments/assets/5b30f6d8-b869-4a2b-b735-e1d9591b86da">
</div>

2. 레디스 stream에서도 XREAD 커맨드를 여러 소비자가 수행한다면 팬아웃이 가능
   - 레디스 stream의 데이터를 여러 소비자가 읽어가는 상황
<div align="center">
<img src="https://github.com/user-attachments/assets/6eae20fe-d518-4ab8-b65b-6f33e77523de">
</div>

   - 위 팬아웃 예제들은 여러 소비자가 stream에 저장된 똑같은 데이터를 읽어가는 상황

3. 하지만, 만약 같은 데이터를 여러 소비자가 나눠서 가져가길 원한다면?
   - 같은 역할을 하는 여러 개의 소비자를 이용해 메세지를 병렬 처리함으로써 서비스 처리 성능을 높일 수 있음
   - stream을 이용해 이벤트 데이터를 처리하는 상황에서 이벤트의 처리 성능을 높이기 위해 여러 소비자를 이용해 한 번에 여러 이벤트를 병렬적으로 처리되도록 구성할 수 있음
   - 이 때 처리되는 메세지 순서가 보장되는 경우와 그렇지 않은 경우에 대해 생각해야 함
     + 예를 들어, 티켓 판매 서비스에서는 고객이 티켓을 결제할 때 카드의 유효성 검사나 사용자 잔고 확인 같은 선행 작업 후 결제 프로세스가 진행되어야 하므로, 이벤트 순서를 보장하는 것이 좋음
     + 반면, 사용자의 회원 가입 이벤트는 각 사용자의 가입 순서를 엄격하게 지키지 않아도 되므로, 메세지를 생성된 순서대로 처리할 필요가 없음

   - 레디스 stream에서는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 저장 : 따라서, 소비자에게 데이터가 전달될 때, 그 순서는 항상 보장
   - 반면 카프카에서 유니크 키는 파티션 내에서만 보장되므로, 소비자가 여러 파티션에서 토픽을 읽어갈 때 데이터 순서를 보장할 수 없음
<div align="center">
<img src="https://github.com/user-attachments/assets/3fd482fe-6aad-4243-abc4-4c996570622a">
</div>

   - 카프카에 저장된 데이터가 소비자에게 팬아웃될 때 순서가 보장되지 않음
   - 메세지는 토픽에 저장될 때 해시함수에 의해 3개의 파티션에 랜덤하게 분배되며, 소비자가 토픽에서 데이터를 소비할 때 파티션의존재를 알지 못하고, 토픽 내 전체 파티션에서 데이터를 읽어옴
   - 이 때, 여러 파티션 간 데이터의 정렬은 보장되지 않으므로 결국 소비자가 데이터를 읽어올 때 정렬이 보장되지 않는 데이터를 읽어오게 됨
   - 따라서, 카프카에서 메세지 순서가 보장되도록 데이터를 처리하기 위해 소비자 그룹을 사용해야함

-----
### 소비자 그룹
-----
1. 카프카에서는 소비자 그룹에 여러 소비자를 추가할 수 있으며, 이 때 소비자는 토픽 내 파티션과 일대일로 연결
<div align="center">
<img src="https://github.com/user-attachments/assets/b354e516-b1fd-4700-8ad5-0f9795d529c4">
</div>

  - 3개의 소비자가 속한 소비자 그룹이 Email이라는 토픽에 연결된 것을 보여줌
  - 이 때, 이메일 서버 (1)은 파티션 2에 연결
  - 파티션 내부에서는 메세지의 순서가 보장되므로 서버 (1)에서 데이터를 읽을 때에는 순서가 보장된 메세지를 읽을 수 있게 됨

2. 레디스 stream에서도 소비자 그룹 개념이 존재하지만, 카프카와는 다름
   - 레디스 stream은 카프카와 달리 메세지가 전달되는 순서를 신경쓰지 않아도 됨
   - 레디스 stream에서 소비자 그룹 내 한 소비자는 다른 소비자가 아직 읽지 않은 데이터만을 읽어감
<div align="center">
<img src="https://github.com/user-attachments/assets/4ace5cdf-92d0-43fa-8eac-a251a18440f0">
</div>

   - 소비자 그룹에 속한 이메일 서버 (2)가 129-0이라는 ID의 메세지를 읽어갔다면, 그 다음 이메일 서버 (1)이 데이터를 읽어갈 때는 133-0을 읽어갈 수 있음
   - 각 요청 시마다 소비자는 stream에서 차례대로 데이터를 가져오게 됨

3. 레디스 stream에서 소비자 그룹을 생성하려면 XGROUP 커맨드 사용
```redis
> XGROUP CREATE Email EmailServiceGroup $
OK
```

   - 이 커맨드를 이용하면 Email stream을 읽어가는 EmailServiceGroup이라는 소비자 그룹을 생성할 수 있으며, $는 현재 시점 이후 데이터부터 리스닝하겠다는 것을 의미

4. 소비자 그룹을 이용해 데이터를 읽어오고 싶다면 XREADGROUP 커맨드 사용
   - XREAD와 같은 형태로 데이터를 응답하지만, 지정한 소비자 그룹을 통해서 데이터를 읽길 원한다는 것을 뜻함
```redis
> XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email >
```
   - EmailServiceGroup에 속한 emailService1이라는 이름의 소비자가 Email stream에 있는 1개의 메세지를 읽어오고자하는 커맨드
   - 매번 소비자가 소비자 그룹을 이용해 작업을 수행할 때마다, 그룹 내 이 소비자를 고유하게 식별할 수 있는 이름을 지정해야 함

5. 만약 다른 소비자에게 읽히지 않은 데이터가 있다면 데이터 1개를 가져오고, 없다면 nil 값을 반환
   - 카프카와 다르게 레디스 stream에서 각 소비자는 COUNT를 이용해 소비할 메세지 개수 직접 지정 가능

6. 위 예제에서 STREAM Email >의 의미 : Email이라는 이름의 stream에서, 다른 소비자에게 전달되지 않았던 새로운 메세지를 전달하라는 것을 의미
   - 소비자 그룹을 사용하는 이유가 다른 소비자에게 전달되지 않았던 데이터를 가지고 오는 것이므로, 대부분 상황에서 >를 사용하면 되겠지만 만약 0 또는 다른 숫자 ID를 입력할 경우, 새로운 메세지를 확인하는 것이 아닌, 입력한 ID보다 큰 ID 중 대기 List(Pending List)에 속하던 메세지를 반환

7. 소비자는 처음 언급될 때 자동으로 생성되며, 명시적으로 생성할 필요는 없음
   - XREADGROUP을 사용하면 여러 stream 데이터를 동시에 읽어올 수 있지만, 이를 가능하게 하기 위해서는 stream에 동일한 이름을 가진 소비자 그룹을 먼저 생성해야 함

8. XREADGROUP을 사용해 stream 데이터를 읽어올 때, 읽어오는 동작 자체가 소비자 그룹에 영향을 미치므로 이를 일종의 쓰기 커맨드로 생각해야 하므로, 이 커맨드는 마스터에서만 호출 가능
9. 레디스 stream에서 소비자 그룹은 stream의 상태를 나타내는 개념으로 간주
    - 보류된 메세지(Pending Message)의 관리 방식과, 새로운 메세지를 요청하는 소비자가 매번 새로운 ID를 할당받을 수 있음
    - 하나의 stream이 여러 개의 소비자 그룹을 가질 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/a4c481f7-7df4-4691-9c30-54299a179b29">
</div>

10. 부하 분산의 관점에서 카프카와 비교
    - 카프카가 파티션이라는 개념을 이용해 소비자의 부하 분산을 관리한다면, 레디스의 stream은 파티션이라는 분할 없이도 소비자 그룹이라는 개념을 이용해 여러 소비자에게 stream의 데이터를 분산시킬 수 있음

11. stream과 소비자 그룹은 독립적으로 동작할 수 있음
    - 즉, Email이라는 stream 메세지를 읽어가기 위한 소비자 그룹은 다수 존재할 수 있으며, 각각 독립적으로 동작
    - 소비자 그룹 1의 소비자가 a라는 메세지를 읽었다면, 같은 그룹에서는 그 메세지를 다시 읽을 수 없지만, 소비자 그룹 2 혹은 일반적인 다른 소비자에서는 해당 메세지에서는 읽을 수 있음
    - 하나의 소비자 그룹에서 여러 개의 stream을 리스닝하는 것도 가능
```redis
> XGROUP CREATE Email BIGroup 0
> XGROUP CREATE Push BIGroup 0

> XREADGROUP GROUP BIGroup BI1 COUNT 2 STREAMS Email Push > >
```
   - XGROUP 커맨드를 이용해 각 stream에 BIGroup이라는 이름을 가진 소비자 그룹을 먼저 생성
   - XREADGROUP 커맨드를 이용해 데이터를 읽으면 BIGroup은 Email과 Push 2개의 stream을 리스닝 할 수 있게 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/58f83b26-e08d-4811-995a-df02d71c893f">
</div>

   - Email과 Push의 두 가지 stream에는 각각 실시간 데이터가 쌓이게 됨
   - EmailServiceGroup 소비자 그룹의 각 이메일 서버들은 Email 서비스의 메세지를 읽어가며, NotificationServiceGroup 소비자 그룹에서는 Email과 Push 2개 stream에서 모두 데이터를 읽어가고 있음
   - BI 서비스는 소비자 그룹을 이용하지 않고 하나의 소비자가 데이터를 읽어가고 있으며, 이 때 각 stream 데이터는 정렬되어 전달

12. 소비자 그룹에 전달되는 모든 데이터는 시간 순으로 정렬되어 있으며, stream에 쌓인 메세지는 해당 데이터가 필요한 여러 서비스에 분산되어 읽힐 수 있음
