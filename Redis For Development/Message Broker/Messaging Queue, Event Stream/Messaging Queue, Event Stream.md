-----
### 메세징 큐와 이벤트 스트림
-----
1. 메세징 큐
<div align="center">
<img src="https://github.com/user-attachments/assets/819d9221-429a-4f09-8dad-51b47c9bcba6">
</div>

   - 데이터를 생성하는 쪽 : 생산자(Producer)
   - 데이터를 수신하는 쪽 : 소비자(Consumer)

2. 이벤트 스트림
<div align="center">
<img src="https://github.com/user-attachments/assets/902dec5f-18ae-4594-8c93-d4f73e05e68f">
</div>

   - 데이터를 생성하는 쪽 : 발행자(Publisher)
   - 데이터를 조회하는 쪽 : 구독자(Subscriber)

3. 메세징 큐와 이벤트 스트림의 차이점
   - 방향성
     + 메세징 큐의 생산자는 소비자 큐로 직접 데이터를 푸시하여, 2개의 서비스에 같은 메세지를 보내야 할 때 메세징 큐를 이용한다면, 생산자는 2개의 각각 다른 메세징 큐에 각각 데이터를 푸시(Push)해야 함
     + 반면 스트림을 이용하면, 생산자는 스트림의 특정 저장소에 하나의 메세지를 보낼 수 있고, 메세지를 읽어가고자 하는 소비자들은 스트림에서 같은 메세지를 풀(Pull)해갈 수 있으므로 메세지를 복제해서 저장하지 않아도 됨

   - 데이터의 영속성
     + 메세징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제
     + 이벤트 스트림에서는 구독자가 읽어간 데이터는 삭제되지 않고, 저장소 설정에 따라 특정 기간 저장될 수 있음

4. 메세지를 보내는 도중 새로운 소비자를 추가할 때, 메세징 큐를 이용하면 소비자는 새롭게 추가된 이후 이벤트만 확인할 수 있음
   - 메세징 큐에서 새로운 소비자가 추가되는 상황
<div align="center">
<img src="https://github.com/user-attachments/assets/34b7251d-1834-429a-8c43-a8dbdf08f880">
</div>

   - 프로듀서가 소비자 A에게 1이라는 메세지를 보낸 이후, 소비자 B를 추가했을 때 소비자 B는 오직 데이터 2만을 확인 가능

5. 하지만 스트림 방식에서는 메세지를 생산할 때 구독자를 지정하지 않고, 스트림에 쌓인 데이터는 일정 기간 동안 지워지지 않으므로 새로 추가된 서비스도 스트림에 남아 있는 이전 데이터의 히스트로리를 볼 수 있음

6. 따라서 메세징 큐는 일대일(1:1) 상황에서 한 서비스가 다른 서비스에게 동작을 지시할 때 유용하게 사용 가능
7. 스트림은 다대다(N:N) 상황에서 유리함
