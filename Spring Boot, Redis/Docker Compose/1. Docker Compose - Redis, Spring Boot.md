-----
### Docker Compose로 Redis, Spring Boot 한 번에 띄울 수 있게 구성
-----
1. Dockerfile
```yaml
FROM openjdk:17-jdk

COPY build/libs/*SNAPSHOT.jar app.jar

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

2. compose.yml
```yml
services:
  api-server:
    build: .
    ports:
      - 8080:8080
    depends_on:
      cache-server:
        condition: service_healthy # 다른 서비스가 시작되기 전에 특정 서비스가 healthy 상태가 되기를 기다리도록 설정
  cache-server: 
    image: redis
    ports:
      - 6379:6379
    healthcheck: # 서비스 상태를 주기적으로 확인해 healthy 상태로 간주할 조건 정의
      test: [ "CMD", "redis-cli", "ping" ] # 성공시 healthy check 통과
      interval: 5s # 5초 간격으로 healthy check
      retries: 10 # 최대 10번까지 실패 허용, 10번 연속 실패하면 이 컨테이너는 unhealthy
```

3. 기존 실행되고 있는 Redis, Spring Boot 종료

4. application.yml 수정
```yml
# local 환경
spring:
  profiles:
    default: local
  datasource:
    url: jdbc:mysql://host.docker.internal:3306/mydb # host.docker.internal : Docker 컨테이너 호스트(= 컨테이너를 실행한 PC 또는 서버)에 접근할 수 있도록 해주는 DNS 이름
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  data:
    redis:
      host: cache-server # compose.yml에서 Redis 설
      port: 6379

logging:
  level:
    org.springframework.cache: trace

---
# prod 환경
spring:
  config:
    activate:
      on-profile: prod
  datasource:
    url: jdbc:mysql://instagram-db.coseefawhrzc.ap-northeast-2.rds.amazonaws.com:3306/mydb
    username: admin
    password: 1234
```

5. Dokcer Container로 실행
```bash
$ ./gradlew clean build -x test
$ docker compose up --build -d

$ docker ps # 잘 띄워졌는 지 확인
$ docker compose logs -f # 실시간 로그 확인하기
```

6. Postman으로 테스트
